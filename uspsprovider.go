package zipfetcher

import (
	"fmt"
	"github.com/antchfx/htmlquery"
	"github.com/itchyny/timefmt-go"
	"github.com/pbnjay/grate"
	"github.com/pbnjay/grate/xls"
	"golang.org/x/net/html"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type UspsProvider struct {
	baseURL         string
	pageURI         string
	LastUpdateDate  time.Time
	LastRequestDate time.Time
	XlsPath         string
	xlsDownloadURI  string
}

func CreateUspsProvider() *UspsProvider {
	return &UspsProvider{
		baseURL: "https://postalpro.usps.com",
		pageURI: "/ZIP_Locale_Detail",
	}
}

func (usps *UspsProvider) GetLastModificationDate() (time.Time, error) {
	if usps.LastRequestDate.IsZero() ||
		usps.LastRequestDate.Before(getCurrentDate()) {
		err := usps.parseSourcePage()
		if err != nil {
			return time.Now(), err
		}
	}
	return usps.LastUpdateDate, nil
}

func (usps *UspsProvider) GetZips() ([]ZipCode, error) {
	if usps.LastRequestDate.IsZero() ||
		usps.LastRequestDate.Before(getCurrentDate()) {
		err := usps.parseSourcePage()
		if err != nil {
			return []ZipCode{}, err
		}
	}

	defer os.RemoveAll(usps.XlsPath)
	err := usps.downloadXls()
	if err != nil {
		return []ZipCode{}, err
	}

	return usps.extractZipsInfo(usps.XlsPath)
}

// get the source page html
func (usps *UspsProvider) parseSourcePage() error {
	usps.LastRequestDate = getCurrentDate()
	doc, err := htmlquery.LoadURL(usps.baseURL + usps.pageURI)
	if err != nil {
		return fmt.Errorf("cannot get the source page: %s", err.Error())
	}

	err = usps.parseDownloadLink(doc)
	if err != nil {
		return err
	}
	return usps.parseLastUpdateDate(doc)
}

// return current day with default start daytime
func getCurrentDate() time.Time {
	return time.Date(time.Now().Year(), time.Now().Month(), time.Now().Day(), 0, 0, 0, 0, time.UTC)
}

// scratch autogenerated link for download the xls from the source page
func (usps *UspsProvider) parseDownloadLink(doc *html.Node) error {
	list := htmlquery.Find(doc, "//a[@class='btn btn-outline-primary mt-1']")
	if len(list) == 0 {
		return fmt.Errorf("failed to get xls download link")
	}
	usps.xlsDownloadURI = htmlquery.SelectAttr(list[0], "href")
	return nil
}

// scratch last update date from source page
func (usps *UspsProvider) parseLastUpdateDate(doc *html.Node) error {
	list := htmlquery.Find(doc, "//div[@class='form-item field field--name-field-description "+
		"field--type-text-with-summary field--label-above']//p//text()")
	if len(list) == 0 {
		return fmt.Errorf("failed to get last update date")
	}

	date := strings.TrimPrefix(list[0].Data, "updated ")
	t, err := timefmt.Parse(date, "%m/%d/%Y")
	if err != nil {
		return fmt.Errorf("failed to get last update date")
	}

	usps.LastUpdateDate = t
	return nil
}

// download the xls in temporary file
func (usps *UspsProvider) downloadXls() error {
	out, _ := os.CreateTemp("", "zips")
	usps.XlsPath = out.Name()

	resp, err := http.Get(usps.baseURL + usps.xlsDownloadURI)
	if err != nil {
		return fmt.Errorf("fail dowmload xls from %s: %s", usps.baseURL+usps.xlsDownloadURI, err.Error())
	}
	defer resp.Body.Close()

	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return fmt.Errorf("fail dowmload xls from %s: %s", usps.baseURL+usps.xlsDownloadURI, err.Error())
	}
	return nil
}

// extract info from all xls sheets
func (usps *UspsProvider) extractZipsInfo(path string) ([]ZipCode, error) {
	source, err := xls.Open(path)
	if err != nil {
		return nil, fmt.Errorf("can't open the file: %s", err.Error())
	}

	l, err := source.List()
	if err != nil {
		return nil, fmt.Errorf("can't get sheets from %s: %s", path, err.Error())
	}

	m := make(map[string]ZipCode) // file contains duplicates, map is used for uniqueness
	for _, table := range l {
		err = extractZipsFromSheet(source, table, m)
		if err != nil {
			return nil, err
		}
	}
	return extractMapValues(m), nil
}

// extract info from a xls sheet list
func extractZipsFromSheet(source grate.Source, table string, m map[string]ZipCode) error {
	collection, err := source.Get(table)
	if err != nil {
		return fmt.Errorf("can't get table %s: %s", table, err.Error())
	}

	collection.Next() // titles row
	collection.Next() // the first row with data
	for !collection.IsEmpty() {
		if collection.Err() != nil {
			return fmt.Errorf("reading error in table %s: %s", table, err.Error())
		}
		if collection.Strings()[ZipColumn[table]] == "" { // ignore empty tail
			break
		}

		row := collection.Strings()
		m[row[ZipColumn[table]]] = ZipCode{
			Code:       row[ZipColumn[table]],
			State:      row[StateColumn[table]],
			City:       row[CityColumn[table]],
			LocaleName: row[LocaleNameColumn[table]],
		}
		collection.Next()
	}
	return nil
}

func extractMapValues(m map[string]ZipCode) []ZipCode {
	zips := make([]ZipCode, 0, len(m))
	for _, z := range m {
		zips = append(zips, z)
	}
	return zips
}

// ZipColumn used to allocate which column in each page contains zips
var ZipColumn = map[string]int{
	"ZIP_DETAIL":        4,
	"Unique_ZIP_DETAIL": 4,
	"Other":             5,
}

// StateColumn used to allocate which column in each page contains states
// Pay attention military zones data don't contain real physical location
var StateColumn = map[string]int{
	"ZIP_DETAIL":        8,
	"Unique_ZIP_DETAIL": 8,
	"Other":             12,
}

// CityColumn used to allocate which column in each page contains city
//
// Pay attention military zones data don't contain real physical location
var CityColumn = map[string]int{
	"ZIP_DETAIL":        7,
	"Unique_ZIP_DETAIL": 7,
	"Other":             11,
}

// LocaleNameColumn used to allocate which column in each page contains locale name
var LocaleNameColumn = map[string]int{
	"ZIP_DETAIL":        5,
	"Unique_ZIP_DETAIL": 5,
	"Other":             7,
}
